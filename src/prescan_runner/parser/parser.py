# Copyright (c) 2023 fortiss GmbH
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

from os import times
import numpy
from utils import geometric
import pandas as pd
import numpy as np

'''
    Parser when working with csv outputs of a compiled experiment.

    input:
        filename_results: path to csv file with evaluation results generated by prescan 
        filename_traces: path to csv file with traces (i.e. position, orientation, velocity data) of designated actors
'''
def parse_output(filename_results, filename_traces):
    res = pd.read_csv(filename_results, names=["metric", "value"])
    res.set_index("metric",inplace=True)

    pd_file = pd.read_csv(filename_traces, names=["ego_x", "ego_y","ego_h", "ego_v","parked_x", "parked_y","parked_h", "parked_v","other_x", "other_y","other_h", "other_v"])
    # output format: 4 x ego vars, 4 x parked car vars, 4 x shopping cart vars
    n_timesteps = len(parseLocation(pd_file,'ego'))

    simout =  {
        "simTime" : res.loc["EndTime (s)"]["value"],
        "times": [t for t in range(n_timesteps)], # TODO add real values
        "location" : { 
            "other" : parseLocation(pd_file,'other'),
            "ego" : parseLocation(pd_file,'ego')
        },
        "velocity" : {
            "other" : parseVelocity(pd_file,'other'),
            "ego" : parseVelocity(pd_file,'ego')
        }, 
        "speed" : {
             "other" : parseVelocity(pd_file,'other'),
            "ego" : parseVelocity(pd_file,'ego')
        }, 
        "yaw" : {
            "other" : parseYaw(pd_file,'other'),
            "ego" : parseYaw(pd_file,'ego'),
        },
        "acceleration" : {
            "other" : n_timesteps*[-100],# TODO add real values
            "ego" : n_timesteps*[-100]# TODO add real values
        },
        "type": {
            "ego" : "vehicle",
            "other" : "pedestrian"
        },
        "collisions" : [], # TODO identify the other vehicle of the collision
        "actors" : { 
                    "ego" : "ego",
                    "adversary" : "other",
                    "vehicles" : [],
                    "pedestrians" : []
        }, # TODO add real values
        "otherParams" : {
            # TODO provide the following static parameters in a different way
            # TODO: car_length and car_width should be set when defining problem
            # PreScan AVP use case values. 
            "car_width" : 1.98,
            "car_length" : 4.31,
            "sampling_rate" : 100,
            "isCollision" : res.loc["Collision with Host (0/1)"]["value"],
            "ego_vimpact" : res.loc["Host velocity at impact (m/s)"]["value"],
            "min_ttc" : res.loc['Minimum TTC (s)']["value"],
            "stopCondition": res.loc["StopCondition"]["value"],
            "endTime" : res.loc["EndTime (s)"]["value"],
            "timeCollision" : -1
        }
    }

    # if simout.otherParams["isCollision"]:
    #     distance = np.norm(simout.location["ego"] - simout.location["other"])
    #     simout.otherParams["timeCollision"] = times[np.argmin(distance)]

    return simout

def parseLocation(pd_file,actor):
    pd_x = pd_file[actor + "_x"]
    pd_y = pd_file[actor + "_y"]
    return [ entry for entry in zip(pd_x.values.tolist(),pd_y.values.tolist())]

def parseVelocity(pd_file,actor):
    pd_v= pd_file[actor + "_v"]
    return pd_v.values.tolist()

# Normalize yaw for prescan
def parseYaw(pd_file,actor):
    pd_v= pd_file[actor + "_h"]
    return [value - 90 for value in pd_v.values.tolist()]

    
